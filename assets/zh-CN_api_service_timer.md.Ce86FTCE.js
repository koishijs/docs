import{_ as a,k as t,m as l,j as o}from"./chunks/framework.CUOHyZ0k.js";const p=JSON.parse('{"title":"计时器 (Timer)","description":"","frontmatter":{},"headers":[],"relativePath":"zh-CN/api/service/timer.md","filePath":"zh-CN/api/service/timer.md"}'),c={name:"zh-CN/api/service/timer.md"};function i(d,e,r,n,s,h){return o(),t("div",null,e[0]||(e[0]=[l('<h1 id="计时器" tabindex="-1">计时器 (Timer) <a class="header-anchor" href="#计时器" aria-label="Permalink to &quot;计时器 (Timer)&quot;">​</a></h1><h2 id="实例方法" tabindex="-1">实例方法 <a class="header-anchor" href="#实例方法" aria-label="Permalink to &quot;实例方法&quot;">​</a></h2><h3 id="ctx-settimeout" tabindex="-1">ctx.setTimeout(callback, delay) <a class="header-anchor" href="#ctx-settimeout" aria-label="Permalink to &quot;ctx.setTimeout(callback, delay)&quot;">​</a></h3><ul><li><strong>callback:</strong> <code>Function</code> 回调函数</li><li><strong>delay:</strong> <code>number</code> 延迟时间 (毫秒)</li><li>返回值: <code>() =&gt; void</code></li></ul><p>在指定的延迟时间后执行回调函数。返回的函数可以用于取消此计时器。</p><h3 id="ctx-setinterval" tabindex="-1">ctx.setInterval(callback, delay) <a class="header-anchor" href="#ctx-setinterval" aria-label="Permalink to &quot;ctx.setInterval(callback, delay)&quot;">​</a></h3><ul><li><strong>callback:</strong> <code>Function</code> 回调函数</li><li><strong>delay:</strong> <code>number</code> 延迟时间 (毫秒)</li><li>返回值: <code>() =&gt; void</code></li></ul><p>在指定的延迟时间后执行回调函数，然后每隔指定的延迟时间重复执行。返回的函数可以用于取消此计时器。</p><h3 id="ctx-sleep" tabindex="-1">ctx.sleep(delay) <a class="header-anchor" href="#ctx-sleep" aria-label="Permalink to &quot;ctx.sleep(delay)&quot;">​</a></h3><ul><li><strong>delay:</strong> <code>number</code> 延迟时间 (毫秒)</li><li>返回值: <code>Promise&lt;void&gt;</code></li></ul><p>等待指定的延迟时间。如果在此期间插件被停用，将会抛出一个错误。</p><h3 id="ctx-throttle" tabindex="-1">ctx.throttle(callback, delay, noTrailing?) <a class="header-anchor" href="#ctx-throttle" aria-label="Permalink to &quot;ctx.throttle(callback, delay, noTrailing?)&quot;">​</a></h3><ul><li><strong>callback:</strong> <code>F extends (...args: any[]) =&gt; void</code> 回调函数</li><li><strong>delay:</strong> <code>number</code> 延迟时间 (毫秒)</li><li><strong>noTrailing:</strong> <code>boolean</code> 是否禁用尾随调用</li><li>返回值: <code>WithDispose&lt;F&gt;</code></li></ul><p>返回一个函数，该函数在指定的周期内最多执行一次。</p><p>具体表现为，此函数被调用后会立即执行，并在接下来的 <code>delay</code> 毫秒内忽略所有调用。</p><p>默认情况下，如果在最后一次实际执行后的一个延迟周期内再次调用返回的函数，则会在此延迟周期结束时再次执行 (即尾随调用)。将 <code>noTrailing</code> 设置为 <code>true</code> 可禁用此行为。</p><p>返回函数的 <code>dispose()</code> 方法可用于取消此计时器。此后所有调用都将被忽略。</p><h3 id="ctx-debounce" tabindex="-1">ctx.debounce(callback, delay) <a class="header-anchor" href="#ctx-debounce" aria-label="Permalink to &quot;ctx.debounce(callback, delay)&quot;">​</a></h3><ul><li><strong>callback:</strong> <code>F extends (...args: any[]) =&gt; void</code> 回调函数</li><li><strong>delay:</strong> <code>number</code> 延迟时间 (毫秒)</li><li>返回值: <code>WithDispose&lt;F&gt;</code></li></ul><p>返回一个函数，该函数会忽略小于指定间隔的所有高频调用。</p><p>具体表现为，此函数被调用后，不会立即执行，而是会等待 <code>delay</code> 毫秒。如果在此期间再次调用返回的函数，则会重新计时。直到 <code>delay</code> 毫秒内没有调用，此函数才会执行。</p><p>返回函数的 <code>dispose()</code> 方法可用于取消此计时器。此后所有调用都将被忽略。</p>',22)]))}const b=a(c,[["render",i]]);export{p as __pageData,b as default};
