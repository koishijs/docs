import{_ as o,k as r,m as a,j as t}from"./chunks/framework.CUOHyZ0k.js";const g=JSON.parse('{"title":"@koishijs/plugin-server","description":"","frontmatter":{},"headers":[],"relativePath":"zh-CN/plugins/develop/server.md","filePath":"zh-CN/plugins/develop/server.md"}'),l={name:"zh-CN/plugins/develop/server.md"};function i(s,e,c,n,d,h){return t(),r("div",null,e[0]||(e[0]=[a('<h1 id="koishijs-plugin-server" tabindex="-1">@koishijs/plugin-server <a class="header-anchor" href="#koishijs-plugin-server" aria-label="Permalink to &quot;@koishijs/plugin-server&quot;">​</a></h1><p>@koishijs/plugin-server 提供了 <code>ctx.server</code> 基础服务，它是一个基于 <a href="https://github.com/koajs/router" target="_blank" rel="noreferrer">Koa Router</a> 的简单路由系统，用于管理 Koishi 应用收到的网络请求。除了 Koa Router 所支持的部分方法外，Router API 还提供了一些额外的功能，例如支持接受 WebSocket 连接等。</p><h2 id="上下文-api" tabindex="-1">上下文 API <a class="header-anchor" href="#上下文-api" aria-label="Permalink to &quot;上下文 API&quot;">​</a></h2><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>请避免使用未在本页列出的方法：</p><ol><li>Koa Router 的 API 并不是副作用安全的。我们对本页列出的方法进行了特殊处理，使其在插件卸载时自动删除路由。但使用其他方法会导致你的插件无法被正常卸载。</li><li>未来可能会不基于 Koa Router 重新实现路由系统。</li></ol></div><h3 id="ctx-server-method" tabindex="-1">ctx.server[method](path, middleware) <a class="header-anchor" href="#ctx-server-method" aria-label="Permalink to &quot;ctx.server[method](path, middleware)&quot;">​</a></h3><ul><li><strong>method:</strong> 可以是 <code>get</code>, <code>post</code>, <code>put</code>, <code>delete</code>, <code>patch</code> 或 <code>all</code> (仅能是小写)</li><li><strong>path:</strong> <code>string | RegExp | (string | RegExp)[]</code> 路径</li><li><strong>middleware:</strong> <code>Function</code> Koa 中间件</li></ul><p>处理特定路径上的网络请求。具体请参见 <a href="https://github.com/koajs/router/blob/master/API.md" target="_blank" rel="noreferrer">这里</a>。</p><h3 id="ctx-server-ws" tabindex="-1">ctx.server.ws(path, handler) <a class="header-anchor" href="#ctx-server-ws" aria-label="Permalink to &quot;ctx.server\\.ws(path, handler)&quot;">​</a></h3><ul><li><strong>path:</strong> <code>string | RegExp | (string | RegExp)[]</code> 路径</li><li><strong>handler:</strong> <code>WebSocketHandler</code> 处理函数，接受下列参数 <ul><li><strong>socket:</strong> <a href="https://github.com/websockets/ws/blob/master/doc/ws.md#class-websocket" target="_blank" rel="noreferrer"><code>WebSocket</code></a> WebSocket 连接</li><li><strong>request:</strong> <a href="https://nodejs.org/api/http.html#class-httpincomingmessage" target="_blank" rel="noreferrer"><code>IncomingMessage</code></a> 网络请求</li></ul></li></ul><p>在给定的路径上支持 WebSocket 连接。</p><h2 id="配置项" tabindex="-1">配置项 <a class="header-anchor" href="#配置项" aria-label="Permalink to &quot;配置项&quot;">​</a></h2><h3 id="config-host" tabindex="-1">config.host <a class="header-anchor" href="#config-host" aria-label="Permalink to &quot;config.host&quot;">​</a></h3><ul><li>类型：<code>string</code></li><li>默认值：<code>&#39;127.0.0.1&#39;</code></li></ul><p>服务器监听的 IP 地址。如果将此设置为 <code>0.0.0.0</code> 将监听所有地址，包括局域网和公网地址。</p><h3 id="config-port" tabindex="-1">config.port <a class="header-anchor" href="#config-port" aria-label="Permalink to &quot;config.port&quot;">​</a></h3><ul><li>类型：<code>number</code></li><li>必需选项</li></ul><p>要监听的初始端口号。Koishi 建议使用 <code>5140</code> 作为默认端口。</p><h3 id="config-maxport" tabindex="-1">config.maxPort <a class="header-anchor" href="#config-maxport" aria-label="Permalink to &quot;config.maxPort&quot;">​</a></h3><ul><li>类型：<code>number</code></li><li>默认值：<a href="#config-port"><code>config.port</code></a></li></ul><p>允许监听的最大端口号。插件启动时，如果设定的端口号被占用，插件会尝试自动切换到下一个端口，直到找到一个可用的端口，或是超出 <code>maxPort</code> 的限制。</p><h3 id="config-selfurl" tabindex="-1">config.selfUrl <a class="header-anchor" href="#config-selfurl" aria-label="Permalink to &quot;config.selfUrl&quot;">​</a></h3><ul><li>类型：<code>string</code></li></ul><p>Koishi 服务暴露在公网的地址。部分插件 (例如 <a href="./../adapter/telegram.html">adapter-telegram</a> 或是 <a href="https://assets.koishi.chat/plugins/local.html" target="_blank" rel="noreferrer">assets-local</a>) 需要用到。</p>',23)]))}const u=o(l,[["render",i]]);export{g as __pageData,u as default};
