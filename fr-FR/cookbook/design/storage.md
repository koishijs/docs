# 插件数据存储

::: tip
本文将回答以下问题：

- 插件数据的最佳存储位置是哪里？
- 什么是零占用原理？为什么插件需要零占用？
:::

## 持久化数据的三种途径

要为一个插件持久化一些数据，大致有三种途径：数据库、本地文件和配置项。

数据库是最常见的数据存储方式。它有着良好的可扩展性，支持高效地查询，并且可以在多个实例间共享数据。事实上，绝大多数有持久化需求的插件都应该使用数据库进行存储。

本地文件则更加灵活。它可以存储任意类型的数据，且访问速度通常比数据库更快。如果插件存在下载的资源、可执行文件和临时文件，就比较适合使用本地文件进行存储。

最后，配置项也是一种持久化数据的方式。不过相比前两种方式，配置项既无法存储大规模数据，又受到数据结构的限制。只有当这些数据确实是配置 (即只会被管理员更改) 时，我们才建议使用配置项。关于配置项持久化的例子，可以参考 [commands](../appendix/commands.md) 插件。

在编写插件时，我们应该根据数据的类型和用途，选择合适的持久化方式。

## 关于存储位置的讨论

一旦你决定使用本地文件管理数据，那么下一个问题就是将这些文件存放在哪里。

### 应当避免的情况

在我们开始介绍最佳实践之前，首先让我们展示两种你绝对不应该使用的位置。

第一，**永远不要使用绝对路径**。这件事非常容易理解，只需要考虑一下 win32 和 POSIX 之间的路径差异，你就会知道一旦使用了绝对路径，你的插件就注定无法在不同的机器上正常工作。

第二，**永远不要使用 (基于插件目录) 的相对路径**。Koishi 的插件实际上就是一个个 npm 包，它们存储于 `node_modules` 目录下。如果你在插件目录下存放数据，那么当任何插件被更新时，这些数据都可能会丢失。此外，如果你的插件占用了 `node_modules` 目录下的文件，整个 Koishi 将无法安装、卸载、更新任何插件，这种情况下你的插件将被标记为不安全。

::: tip
请注意，第二种情况其实包含了一种隐蔽的场景，那就是基于 gyp 的插件。由于 Node.js 自身的缺陷，`.node` 文件一经加载，就会永久占用该文件。而绝大多数基于 gyp 的包也都会将 `.node` 文件置于 `node_modules` 目录下。因此，依赖这些包的插件也会被标记为不安全。

如果你的插件已经因此被标记为不安全，请尝试排除上述依赖，并使用以下替代方案：

- 更换为 JS 原生实现或 WebAssembly 实现的包 (它们不存在占用问题)。
- 将 `.node` 或其他存在占用问题的可执行文件存放于[全局路径](#global)下。
:::

### 零占用原理

零占用原理是指，给定一个正在运行的 Koishi 实例，移除该实例目录下的所有内容，实例应按照预期的方式保持工作。具体而言，实例内的所有模块，包括 Koishi 本体及所有插件，均在设计时对此情况做了考虑，并编写了相应的处理逻辑：

- Koishi 本体在启动时读取了配置文件。在启动后删除该文件，Koishi 保持工作。
- 存储大文件的插件在要求时加载、解析大文件并返回结果给用户。删除该文件后，插件无法顺利解析，但插件返回可读的错误文本或输出可读的错误日志，不会造成 Koishi 奔溃。
- 外部程序包装插件依赖外部的可执行文件进行工作。可执行文件在运行时无法解除占用，因此在安装时转移至实例目录之外。实例运行时，实例目录内不存在被占用的可执行文件。

实现了「零占用的 Koishi」模式的 Koishi 项目将会获得以下优点：

- **自更新**：可以通过插件更新 Koishi 及其依赖。在更新依赖的整个过程中，Koishi 及所有插件仍保持可用。目前已有 [market](../../plugins/console/market.md) 插件实现了此特性。
- **健壮性**：文件暂时无法访问不会导致 Koishi 崩溃。这对实例目录使用网络映射的场景更友好。
- **滚动更新**：可以先升级实例目录，然后滚动更新 Koishi。这将极大地提高 Koishi 的可用性。
